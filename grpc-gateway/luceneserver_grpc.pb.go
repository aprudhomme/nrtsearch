// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.15.0
// source: yelp/nrtsearch/luceneserver.proto

package nrtsearch

import (
	context "context"
	httpbody "google.golang.org/genproto/googleapis/api/httpbody"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	anypb "google.golang.org/protobuf/types/known/anypb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// LuceneServerClient is the client API for LuceneServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LuceneServerClient interface {
	// Create an Index
	CreateIndex(ctx context.Context, in *CreateIndexRequest, opts ...grpc.CallOption) (*CreateIndexResponse, error)
	// Change global offline or online settings for this index.
	LiveSettings(ctx context.Context, in *LiveSettingsRequest, opts ...grpc.CallOption) (*LiveSettingsResponse, error)
	// Change global offline or online settings for this index.
	LiveSettingsV2(ctx context.Context, in *LiveSettingsV2Request, opts ...grpc.CallOption) (*LiveSettingsV2Response, error)
	// Registers one or more fields.  Fields must be registered before they can be added in a document (via @addDocument).
	// Pass a list of Fields and an indexName. Any number of fields may be registered in a single request,
	// and once a field is registered it cannot be changed (write-once).
	// This returns the full set of fields currently registered.
	RegisterFields(ctx context.Context, in *FieldDefRequest, opts ...grpc.CallOption) (*FieldDefResponse, error)
	// Adds one or more fields.  Fields must be registered before they can be added in a document (via @addDocument).
	// Pass a list of Fields and an indexName. Any number of fields may be registered in a single request,
	// and once a field is registered it cannot be changed (write-once).
	// This returns the full set of fields currently registered.
	UpdateFields(ctx context.Context, in *FieldDefRequest, opts ...grpc.CallOption) (*FieldDefResponse, error)
	// Change global offline settings for this index.
	// This returns the currently set settings; pass no settings changes to retrieve current settings.
	Settings(ctx context.Context, in *SettingsRequest, opts ...grpc.CallOption) (*SettingsResponse, error)
	// Change global offline settings for this index.
	// This returns the currently set settings; pass no settings to retrieve current settings.
	SettingsV2(ctx context.Context, in *SettingsV2Request, opts ...grpc.CallOption) (*SettingsV2Response, error)
	// Starts an index
	StartIndex(ctx context.Context, in *StartIndexRequest, opts ...grpc.CallOption) (*StartIndexResponse, error)
	// Starts an index using configuration in IndexStartConfig
	StartIndexV2(ctx context.Context, in *StartIndexV2Request, opts ...grpc.CallOption) (*StartIndexResponse, error)
	// Stops an index
	StopIndex(ctx context.Context, in *StopIndexRequest, opts ...grpc.CallOption) (*DummyResponse, error)
	// Reload state from the backend
	ReloadState(ctx context.Context, in *ReloadStateRequest, opts ...grpc.CallOption) (*ReloadStateResponse, error)
	// Adds a stream of Documents
	AddDocuments(ctx context.Context, opts ...grpc.CallOption) (LuceneServer_AddDocumentsClient, error)
	// Refresh the latest searcher for an index
	Refresh(ctx context.Context, in *RefreshRequest, opts ...grpc.CallOption) (*RefreshResponse, error)
	// Commits all pending changes to durable storage
	Commit(ctx context.Context, in *CommitRequest, opts ...grpc.CallOption) (*CommitResponse, error)
	// Retrieve index statistics
	Stats(ctx context.Context, in *StatsRequest, opts ...grpc.CallOption) (*StatsResponse, error)
	// Search
	Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	// Search V2
	SearchV2(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*anypb.Any, error)
	// Delete documents
	Delete(ctx context.Context, in *AddDocumentRequest, opts ...grpc.CallOption) (*AddDocumentResponse, error)
	// Delete documents matching a query
	DeleteByQuery(ctx context.Context, in *DeleteByQueryRequest, opts ...grpc.CallOption) (*AddDocumentResponse, error)
	// Delete all documents for index
	DeleteAll(ctx context.Context, in *DeleteAllDocumentsRequest, opts ...grpc.CallOption) (*DeleteAllDocumentsResponse, error)
	// Delete index
	DeleteIndex(ctx context.Context, in *DeleteIndexRequest, opts ...grpc.CallOption) (*DeleteIndexResponse, error)
	// Builds a new auto-suggester, loading suggestions via the provided local file path.
	BuildSuggest(ctx context.Context, in *BuildSuggestRequest, opts ...grpc.CallOption) (*BuildSuggestResponse, error)
	// Perform an auto-suggest lookup.
	SuggestLookup(ctx context.Context, in *SuggestLookupRequest, opts ...grpc.CallOption) (*SuggestLookupResponse, error)
	// Updates existing suggestions, if the suggester supports near-real-time changes.
	UpdateSuggest(ctx context.Context, in *BuildSuggestRequest, opts ...grpc.CallOption) (*BuildSuggestResponse, error)
	// Creates a snapshot in the index, which is saved point-in-time view of the last commit
	// in the index such that no files referenced by that snapshot will be deleted by ongoing
	// indexing until the snapshot is released with @releaseSnapshot.  Note that this will
	// reference the last commit, so be sure to call commit first if you have pending changes
	// that you'd like to be included in the snapshot.
	// This can be used for backup purposes, i.e. after creating the snapshot you can copy
	// all referenced files to backup storage, and then release the snapshot once complete.
	// To restore the backup, just copy all the files back and restart the server.
	// It can also be used for transactional purposes, i.e. if you sometimes need to search a
	// specific snapshot instead of the current live index. Creating a snapshot is very fast
	// (does not require any file copying), but over time it will consume extra disk space as
	// old segments are merged in the index.  Be sure to release the snapshot once you're done.
	// Snapshots survive shutdown and restart of the server.  Returns all protected filenames
	// referenced by this snapshot: these files will not change and will not be deleted until
	// the snapshot is released.  This returns the directories and files referenced by the snapshot.
	CreateSnapshot(ctx context.Context, in *CreateSnapshotRequest, opts ...grpc.CallOption) (*CreateSnapshotResponse, error)
	// releases a snapshot previously created with @createSnapshot.
	ReleaseSnapshot(ctx context.Context, in *ReleaseSnapshotRequest, opts ...grpc.CallOption) (*ReleaseSnapshotResponse, error)
	// Gets all unreleased index gens of snapshots previously created with @createSnapshot.
	GetAllSnapshotIndexGen(ctx context.Context, in *GetAllSnapshotGenRequest, opts ...grpc.CallOption) (*GetAllSnapshotGenResponse, error)
	// backs up a resource (index) and it associated metadata e.g. settings, schema to s3
	BackupIndex(ctx context.Context, in *BackupIndexRequest, opts ...grpc.CallOption) (*BackupIndexResponse, error)
	DeleteIndexBackup(ctx context.Context, in *DeleteIndexBackupRequest, opts ...grpc.CallOption) (*DeleteIndexBackupResponse, error)
	// Backup warming queries to S3
	BackupWarmingQueries(ctx context.Context, in *BackupWarmingQueriesRequest, opts ...grpc.CallOption) (*BackupWarmingQueriesResponse, error)
	// Gets the state of a started index, includes settings, live_settings, search schema, suggest schema
	State(ctx context.Context, in *StateRequest, opts ...grpc.CallOption) (*StateResponse, error)
	// healthcheck
	Status(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
	// Checks if a node is ready to receive traffic by checking if all the indices (which can be preloaded)
	// are started. Can specify comma-separated list of index name to only check specific indices if needed.
	Ready(ctx context.Context, in *ReadyCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
	// metrics
	Metrics(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*httpbody.HttpBody, error)
	// indices
	Indices(ctx context.Context, in *IndicesRequest, opts ...grpc.CallOption) (*IndicesResponse, error)
	// Forces merge policy to merge segments until there are <= maxNumSegments. The actual
	// merges to be executed are determined by the MergePolicy. This call will merge those
	// segments present in the index when the call started. If other threads are still
	// adding documents and flushing segments, those newly created segments will not be
	// merged unless you call forceMerge again.
	ForceMerge(ctx context.Context, in *ForceMergeRequest, opts ...grpc.CallOption) (*ForceMergeResponse, error)
	// Forces merging of all segments that have deleted documents. The actual merges to be
	// executed are determined by the MergePolicy. For example, the default TieredMergePolicy
	// will only pick a segment if the percentage of deleted docs is over 10%.
	// This method first flushes a new segment (if there are indexed documents), and applies
	// all buffered deletes.
	ForceMergeDeletes(ctx context.Context, in *ForceMergeDeletesRequest, opts ...grpc.CallOption) (*ForceMergeDeletesResponse, error)
	// Process request in a plugin which implements CustomRequestPlugin interface.
	Custom(ctx context.Context, in *CustomRequest, opts ...grpc.CallOption) (*CustomResponse, error)
}

type luceneServerClient struct {
	cc grpc.ClientConnInterface
}

func NewLuceneServerClient(cc grpc.ClientConnInterface) LuceneServerClient {
	return &luceneServerClient{cc}
}

func (c *luceneServerClient) CreateIndex(ctx context.Context, in *CreateIndexRequest, opts ...grpc.CallOption) (*CreateIndexResponse, error) {
	out := new(CreateIndexResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/createIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) LiveSettings(ctx context.Context, in *LiveSettingsRequest, opts ...grpc.CallOption) (*LiveSettingsResponse, error) {
	out := new(LiveSettingsResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/liveSettings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) LiveSettingsV2(ctx context.Context, in *LiveSettingsV2Request, opts ...grpc.CallOption) (*LiveSettingsV2Response, error) {
	out := new(LiveSettingsV2Response)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/liveSettingsV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) RegisterFields(ctx context.Context, in *FieldDefRequest, opts ...grpc.CallOption) (*FieldDefResponse, error) {
	out := new(FieldDefResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/registerFields", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) UpdateFields(ctx context.Context, in *FieldDefRequest, opts ...grpc.CallOption) (*FieldDefResponse, error) {
	out := new(FieldDefResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/updateFields", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) Settings(ctx context.Context, in *SettingsRequest, opts ...grpc.CallOption) (*SettingsResponse, error) {
	out := new(SettingsResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/settings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) SettingsV2(ctx context.Context, in *SettingsV2Request, opts ...grpc.CallOption) (*SettingsV2Response, error) {
	out := new(SettingsV2Response)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/settingsV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) StartIndex(ctx context.Context, in *StartIndexRequest, opts ...grpc.CallOption) (*StartIndexResponse, error) {
	out := new(StartIndexResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/startIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) StartIndexV2(ctx context.Context, in *StartIndexV2Request, opts ...grpc.CallOption) (*StartIndexResponse, error) {
	out := new(StartIndexResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/startIndexV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) StopIndex(ctx context.Context, in *StopIndexRequest, opts ...grpc.CallOption) (*DummyResponse, error) {
	out := new(DummyResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/stopIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) ReloadState(ctx context.Context, in *ReloadStateRequest, opts ...grpc.CallOption) (*ReloadStateResponse, error) {
	out := new(ReloadStateResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/reloadState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) AddDocuments(ctx context.Context, opts ...grpc.CallOption) (LuceneServer_AddDocumentsClient, error) {
	stream, err := c.cc.NewStream(ctx, &LuceneServer_ServiceDesc.Streams[0], "/luceneserver.LuceneServer/addDocuments", opts...)
	if err != nil {
		return nil, err
	}
	x := &luceneServerAddDocumentsClient{stream}
	return x, nil
}

type LuceneServer_AddDocumentsClient interface {
	Send(*AddDocumentRequest) error
	CloseAndRecv() (*AddDocumentResponse, error)
	grpc.ClientStream
}

type luceneServerAddDocumentsClient struct {
	grpc.ClientStream
}

func (x *luceneServerAddDocumentsClient) Send(m *AddDocumentRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *luceneServerAddDocumentsClient) CloseAndRecv() (*AddDocumentResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(AddDocumentResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *luceneServerClient) Refresh(ctx context.Context, in *RefreshRequest, opts ...grpc.CallOption) (*RefreshResponse, error) {
	out := new(RefreshResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/refresh", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) Commit(ctx context.Context, in *CommitRequest, opts ...grpc.CallOption) (*CommitResponse, error) {
	out := new(CommitResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/commit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) Stats(ctx context.Context, in *StatsRequest, opts ...grpc.CallOption) (*StatsResponse, error) {
	out := new(StatsResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/stats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	out := new(SearchResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/search", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) SearchV2(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*anypb.Any, error) {
	out := new(anypb.Any)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/searchV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) Delete(ctx context.Context, in *AddDocumentRequest, opts ...grpc.CallOption) (*AddDocumentResponse, error) {
	out := new(AddDocumentResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) DeleteByQuery(ctx context.Context, in *DeleteByQueryRequest, opts ...grpc.CallOption) (*AddDocumentResponse, error) {
	out := new(AddDocumentResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/deleteByQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) DeleteAll(ctx context.Context, in *DeleteAllDocumentsRequest, opts ...grpc.CallOption) (*DeleteAllDocumentsResponse, error) {
	out := new(DeleteAllDocumentsResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/deleteAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) DeleteIndex(ctx context.Context, in *DeleteIndexRequest, opts ...grpc.CallOption) (*DeleteIndexResponse, error) {
	out := new(DeleteIndexResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/deleteIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) BuildSuggest(ctx context.Context, in *BuildSuggestRequest, opts ...grpc.CallOption) (*BuildSuggestResponse, error) {
	out := new(BuildSuggestResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/buildSuggest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) SuggestLookup(ctx context.Context, in *SuggestLookupRequest, opts ...grpc.CallOption) (*SuggestLookupResponse, error) {
	out := new(SuggestLookupResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/suggestLookup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) UpdateSuggest(ctx context.Context, in *BuildSuggestRequest, opts ...grpc.CallOption) (*BuildSuggestResponse, error) {
	out := new(BuildSuggestResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/updateSuggest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) CreateSnapshot(ctx context.Context, in *CreateSnapshotRequest, opts ...grpc.CallOption) (*CreateSnapshotResponse, error) {
	out := new(CreateSnapshotResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/createSnapshot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) ReleaseSnapshot(ctx context.Context, in *ReleaseSnapshotRequest, opts ...grpc.CallOption) (*ReleaseSnapshotResponse, error) {
	out := new(ReleaseSnapshotResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/releaseSnapshot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) GetAllSnapshotIndexGen(ctx context.Context, in *GetAllSnapshotGenRequest, opts ...grpc.CallOption) (*GetAllSnapshotGenResponse, error) {
	out := new(GetAllSnapshotGenResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/getAllSnapshotIndexGen", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) BackupIndex(ctx context.Context, in *BackupIndexRequest, opts ...grpc.CallOption) (*BackupIndexResponse, error) {
	out := new(BackupIndexResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/backupIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) DeleteIndexBackup(ctx context.Context, in *DeleteIndexBackupRequest, opts ...grpc.CallOption) (*DeleteIndexBackupResponse, error) {
	out := new(DeleteIndexBackupResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/deleteIndexBackup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) BackupWarmingQueries(ctx context.Context, in *BackupWarmingQueriesRequest, opts ...grpc.CallOption) (*BackupWarmingQueriesResponse, error) {
	out := new(BackupWarmingQueriesResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/backupWarmingQueries", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) State(ctx context.Context, in *StateRequest, opts ...grpc.CallOption) (*StateResponse, error) {
	out := new(StateResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/state", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) Status(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/status", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) Ready(ctx context.Context, in *ReadyCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/ready", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) Metrics(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*httpbody.HttpBody, error) {
	out := new(httpbody.HttpBody)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/metrics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) Indices(ctx context.Context, in *IndicesRequest, opts ...grpc.CallOption) (*IndicesResponse, error) {
	out := new(IndicesResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/indices", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) ForceMerge(ctx context.Context, in *ForceMergeRequest, opts ...grpc.CallOption) (*ForceMergeResponse, error) {
	out := new(ForceMergeResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/forceMerge", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) ForceMergeDeletes(ctx context.Context, in *ForceMergeDeletesRequest, opts ...grpc.CallOption) (*ForceMergeDeletesResponse, error) {
	out := new(ForceMergeDeletesResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/forceMergeDeletes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luceneServerClient) Custom(ctx context.Context, in *CustomRequest, opts ...grpc.CallOption) (*CustomResponse, error) {
	out := new(CustomResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.LuceneServer/custom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LuceneServerServer is the server API for LuceneServer service.
// All implementations must embed UnimplementedLuceneServerServer
// for forward compatibility
type LuceneServerServer interface {
	// Create an Index
	CreateIndex(context.Context, *CreateIndexRequest) (*CreateIndexResponse, error)
	// Change global offline or online settings for this index.
	LiveSettings(context.Context, *LiveSettingsRequest) (*LiveSettingsResponse, error)
	// Change global offline or online settings for this index.
	LiveSettingsV2(context.Context, *LiveSettingsV2Request) (*LiveSettingsV2Response, error)
	// Registers one or more fields.  Fields must be registered before they can be added in a document (via @addDocument).
	// Pass a list of Fields and an indexName. Any number of fields may be registered in a single request,
	// and once a field is registered it cannot be changed (write-once).
	// This returns the full set of fields currently registered.
	RegisterFields(context.Context, *FieldDefRequest) (*FieldDefResponse, error)
	// Adds one or more fields.  Fields must be registered before they can be added in a document (via @addDocument).
	// Pass a list of Fields and an indexName. Any number of fields may be registered in a single request,
	// and once a field is registered it cannot be changed (write-once).
	// This returns the full set of fields currently registered.
	UpdateFields(context.Context, *FieldDefRequest) (*FieldDefResponse, error)
	// Change global offline settings for this index.
	// This returns the currently set settings; pass no settings changes to retrieve current settings.
	Settings(context.Context, *SettingsRequest) (*SettingsResponse, error)
	// Change global offline settings for this index.
	// This returns the currently set settings; pass no settings to retrieve current settings.
	SettingsV2(context.Context, *SettingsV2Request) (*SettingsV2Response, error)
	// Starts an index
	StartIndex(context.Context, *StartIndexRequest) (*StartIndexResponse, error)
	// Starts an index using configuration in IndexStartConfig
	StartIndexV2(context.Context, *StartIndexV2Request) (*StartIndexResponse, error)
	// Stops an index
	StopIndex(context.Context, *StopIndexRequest) (*DummyResponse, error)
	// Reload state from the backend
	ReloadState(context.Context, *ReloadStateRequest) (*ReloadStateResponse, error)
	// Adds a stream of Documents
	AddDocuments(LuceneServer_AddDocumentsServer) error
	// Refresh the latest searcher for an index
	Refresh(context.Context, *RefreshRequest) (*RefreshResponse, error)
	// Commits all pending changes to durable storage
	Commit(context.Context, *CommitRequest) (*CommitResponse, error)
	// Retrieve index statistics
	Stats(context.Context, *StatsRequest) (*StatsResponse, error)
	// Search
	Search(context.Context, *SearchRequest) (*SearchResponse, error)
	// Search V2
	SearchV2(context.Context, *SearchRequest) (*anypb.Any, error)
	// Delete documents
	Delete(context.Context, *AddDocumentRequest) (*AddDocumentResponse, error)
	// Delete documents matching a query
	DeleteByQuery(context.Context, *DeleteByQueryRequest) (*AddDocumentResponse, error)
	// Delete all documents for index
	DeleteAll(context.Context, *DeleteAllDocumentsRequest) (*DeleteAllDocumentsResponse, error)
	// Delete index
	DeleteIndex(context.Context, *DeleteIndexRequest) (*DeleteIndexResponse, error)
	// Builds a new auto-suggester, loading suggestions via the provided local file path.
	BuildSuggest(context.Context, *BuildSuggestRequest) (*BuildSuggestResponse, error)
	// Perform an auto-suggest lookup.
	SuggestLookup(context.Context, *SuggestLookupRequest) (*SuggestLookupResponse, error)
	// Updates existing suggestions, if the suggester supports near-real-time changes.
	UpdateSuggest(context.Context, *BuildSuggestRequest) (*BuildSuggestResponse, error)
	// Creates a snapshot in the index, which is saved point-in-time view of the last commit
	// in the index such that no files referenced by that snapshot will be deleted by ongoing
	// indexing until the snapshot is released with @releaseSnapshot.  Note that this will
	// reference the last commit, so be sure to call commit first if you have pending changes
	// that you'd like to be included in the snapshot.
	// This can be used for backup purposes, i.e. after creating the snapshot you can copy
	// all referenced files to backup storage, and then release the snapshot once complete.
	// To restore the backup, just copy all the files back and restart the server.
	// It can also be used for transactional purposes, i.e. if you sometimes need to search a
	// specific snapshot instead of the current live index. Creating a snapshot is very fast
	// (does not require any file copying), but over time it will consume extra disk space as
	// old segments are merged in the index.  Be sure to release the snapshot once you're done.
	// Snapshots survive shutdown and restart of the server.  Returns all protected filenames
	// referenced by this snapshot: these files will not change and will not be deleted until
	// the snapshot is released.  This returns the directories and files referenced by the snapshot.
	CreateSnapshot(context.Context, *CreateSnapshotRequest) (*CreateSnapshotResponse, error)
	// releases a snapshot previously created with @createSnapshot.
	ReleaseSnapshot(context.Context, *ReleaseSnapshotRequest) (*ReleaseSnapshotResponse, error)
	// Gets all unreleased index gens of snapshots previously created with @createSnapshot.
	GetAllSnapshotIndexGen(context.Context, *GetAllSnapshotGenRequest) (*GetAllSnapshotGenResponse, error)
	// backs up a resource (index) and it associated metadata e.g. settings, schema to s3
	BackupIndex(context.Context, *BackupIndexRequest) (*BackupIndexResponse, error)
	DeleteIndexBackup(context.Context, *DeleteIndexBackupRequest) (*DeleteIndexBackupResponse, error)
	// Backup warming queries to S3
	BackupWarmingQueries(context.Context, *BackupWarmingQueriesRequest) (*BackupWarmingQueriesResponse, error)
	// Gets the state of a started index, includes settings, live_settings, search schema, suggest schema
	State(context.Context, *StateRequest) (*StateResponse, error)
	// healthcheck
	Status(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	// Checks if a node is ready to receive traffic by checking if all the indices (which can be preloaded)
	// are started. Can specify comma-separated list of index name to only check specific indices if needed.
	Ready(context.Context, *ReadyCheckRequest) (*HealthCheckResponse, error)
	// metrics
	Metrics(context.Context, *emptypb.Empty) (*httpbody.HttpBody, error)
	// indices
	Indices(context.Context, *IndicesRequest) (*IndicesResponse, error)
	// Forces merge policy to merge segments until there are <= maxNumSegments. The actual
	// merges to be executed are determined by the MergePolicy. This call will merge those
	// segments present in the index when the call started. If other threads are still
	// adding documents and flushing segments, those newly created segments will not be
	// merged unless you call forceMerge again.
	ForceMerge(context.Context, *ForceMergeRequest) (*ForceMergeResponse, error)
	// Forces merging of all segments that have deleted documents. The actual merges to be
	// executed are determined by the MergePolicy. For example, the default TieredMergePolicy
	// will only pick a segment if the percentage of deleted docs is over 10%.
	// This method first flushes a new segment (if there are indexed documents), and applies
	// all buffered deletes.
	ForceMergeDeletes(context.Context, *ForceMergeDeletesRequest) (*ForceMergeDeletesResponse, error)
	// Process request in a plugin which implements CustomRequestPlugin interface.
	Custom(context.Context, *CustomRequest) (*CustomResponse, error)
	mustEmbedUnimplementedLuceneServerServer()
}

// UnimplementedLuceneServerServer must be embedded to have forward compatible implementations.
type UnimplementedLuceneServerServer struct {
}

func (UnimplementedLuceneServerServer) CreateIndex(context.Context, *CreateIndexRequest) (*CreateIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateIndex not implemented")
}
func (UnimplementedLuceneServerServer) LiveSettings(context.Context, *LiveSettingsRequest) (*LiveSettingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LiveSettings not implemented")
}
func (UnimplementedLuceneServerServer) LiveSettingsV2(context.Context, *LiveSettingsV2Request) (*LiveSettingsV2Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LiveSettingsV2 not implemented")
}
func (UnimplementedLuceneServerServer) RegisterFields(context.Context, *FieldDefRequest) (*FieldDefResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterFields not implemented")
}
func (UnimplementedLuceneServerServer) UpdateFields(context.Context, *FieldDefRequest) (*FieldDefResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateFields not implemented")
}
func (UnimplementedLuceneServerServer) Settings(context.Context, *SettingsRequest) (*SettingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Settings not implemented")
}
func (UnimplementedLuceneServerServer) SettingsV2(context.Context, *SettingsV2Request) (*SettingsV2Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SettingsV2 not implemented")
}
func (UnimplementedLuceneServerServer) StartIndex(context.Context, *StartIndexRequest) (*StartIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartIndex not implemented")
}
func (UnimplementedLuceneServerServer) StartIndexV2(context.Context, *StartIndexV2Request) (*StartIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartIndexV2 not implemented")
}
func (UnimplementedLuceneServerServer) StopIndex(context.Context, *StopIndexRequest) (*DummyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopIndex not implemented")
}
func (UnimplementedLuceneServerServer) ReloadState(context.Context, *ReloadStateRequest) (*ReloadStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReloadState not implemented")
}
func (UnimplementedLuceneServerServer) AddDocuments(LuceneServer_AddDocumentsServer) error {
	return status.Errorf(codes.Unimplemented, "method AddDocuments not implemented")
}
func (UnimplementedLuceneServerServer) Refresh(context.Context, *RefreshRequest) (*RefreshResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Refresh not implemented")
}
func (UnimplementedLuceneServerServer) Commit(context.Context, *CommitRequest) (*CommitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Commit not implemented")
}
func (UnimplementedLuceneServerServer) Stats(context.Context, *StatsRequest) (*StatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stats not implemented")
}
func (UnimplementedLuceneServerServer) Search(context.Context, *SearchRequest) (*SearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedLuceneServerServer) SearchV2(context.Context, *SearchRequest) (*anypb.Any, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchV2 not implemented")
}
func (UnimplementedLuceneServerServer) Delete(context.Context, *AddDocumentRequest) (*AddDocumentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedLuceneServerServer) DeleteByQuery(context.Context, *DeleteByQueryRequest) (*AddDocumentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteByQuery not implemented")
}
func (UnimplementedLuceneServerServer) DeleteAll(context.Context, *DeleteAllDocumentsRequest) (*DeleteAllDocumentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAll not implemented")
}
func (UnimplementedLuceneServerServer) DeleteIndex(context.Context, *DeleteIndexRequest) (*DeleteIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteIndex not implemented")
}
func (UnimplementedLuceneServerServer) BuildSuggest(context.Context, *BuildSuggestRequest) (*BuildSuggestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuildSuggest not implemented")
}
func (UnimplementedLuceneServerServer) SuggestLookup(context.Context, *SuggestLookupRequest) (*SuggestLookupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SuggestLookup not implemented")
}
func (UnimplementedLuceneServerServer) UpdateSuggest(context.Context, *BuildSuggestRequest) (*BuildSuggestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSuggest not implemented")
}
func (UnimplementedLuceneServerServer) CreateSnapshot(context.Context, *CreateSnapshotRequest) (*CreateSnapshotResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSnapshot not implemented")
}
func (UnimplementedLuceneServerServer) ReleaseSnapshot(context.Context, *ReleaseSnapshotRequest) (*ReleaseSnapshotResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReleaseSnapshot not implemented")
}
func (UnimplementedLuceneServerServer) GetAllSnapshotIndexGen(context.Context, *GetAllSnapshotGenRequest) (*GetAllSnapshotGenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllSnapshotIndexGen not implemented")
}
func (UnimplementedLuceneServerServer) BackupIndex(context.Context, *BackupIndexRequest) (*BackupIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BackupIndex not implemented")
}
func (UnimplementedLuceneServerServer) DeleteIndexBackup(context.Context, *DeleteIndexBackupRequest) (*DeleteIndexBackupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteIndexBackup not implemented")
}
func (UnimplementedLuceneServerServer) BackupWarmingQueries(context.Context, *BackupWarmingQueriesRequest) (*BackupWarmingQueriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BackupWarmingQueries not implemented")
}
func (UnimplementedLuceneServerServer) State(context.Context, *StateRequest) (*StateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method State not implemented")
}
func (UnimplementedLuceneServerServer) Status(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedLuceneServerServer) Ready(context.Context, *ReadyCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ready not implemented")
}
func (UnimplementedLuceneServerServer) Metrics(context.Context, *emptypb.Empty) (*httpbody.HttpBody, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Metrics not implemented")
}
func (UnimplementedLuceneServerServer) Indices(context.Context, *IndicesRequest) (*IndicesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Indices not implemented")
}
func (UnimplementedLuceneServerServer) ForceMerge(context.Context, *ForceMergeRequest) (*ForceMergeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ForceMerge not implemented")
}
func (UnimplementedLuceneServerServer) ForceMergeDeletes(context.Context, *ForceMergeDeletesRequest) (*ForceMergeDeletesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ForceMergeDeletes not implemented")
}
func (UnimplementedLuceneServerServer) Custom(context.Context, *CustomRequest) (*CustomResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Custom not implemented")
}
func (UnimplementedLuceneServerServer) mustEmbedUnimplementedLuceneServerServer() {}

// UnsafeLuceneServerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LuceneServerServer will
// result in compilation errors.
type UnsafeLuceneServerServer interface {
	mustEmbedUnimplementedLuceneServerServer()
}

func RegisterLuceneServerServer(s grpc.ServiceRegistrar, srv LuceneServerServer) {
	s.RegisterService(&LuceneServer_ServiceDesc, srv)
}

func _LuceneServer_CreateIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).CreateIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/createIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).CreateIndex(ctx, req.(*CreateIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_LiveSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LiveSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).LiveSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/liveSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).LiveSettings(ctx, req.(*LiveSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_LiveSettingsV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LiveSettingsV2Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).LiveSettingsV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/liveSettingsV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).LiveSettingsV2(ctx, req.(*LiveSettingsV2Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_RegisterFields_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FieldDefRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).RegisterFields(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/registerFields",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).RegisterFields(ctx, req.(*FieldDefRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_UpdateFields_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FieldDefRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).UpdateFields(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/updateFields",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).UpdateFields(ctx, req.(*FieldDefRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_Settings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).Settings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/settings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).Settings(ctx, req.(*SettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_SettingsV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SettingsV2Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).SettingsV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/settingsV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).SettingsV2(ctx, req.(*SettingsV2Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_StartIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).StartIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/startIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).StartIndex(ctx, req.(*StartIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_StartIndexV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartIndexV2Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).StartIndexV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/startIndexV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).StartIndexV2(ctx, req.(*StartIndexV2Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_StopIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).StopIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/stopIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).StopIndex(ctx, req.(*StopIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_ReloadState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReloadStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).ReloadState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/reloadState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).ReloadState(ctx, req.(*ReloadStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_AddDocuments_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LuceneServerServer).AddDocuments(&luceneServerAddDocumentsServer{stream})
}

type LuceneServer_AddDocumentsServer interface {
	SendAndClose(*AddDocumentResponse) error
	Recv() (*AddDocumentRequest, error)
	grpc.ServerStream
}

type luceneServerAddDocumentsServer struct {
	grpc.ServerStream
}

func (x *luceneServerAddDocumentsServer) SendAndClose(m *AddDocumentResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *luceneServerAddDocumentsServer) Recv() (*AddDocumentRequest, error) {
	m := new(AddDocumentRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _LuceneServer_Refresh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).Refresh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/refresh",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).Refresh(ctx, req.(*RefreshRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_Commit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).Commit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/commit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).Commit(ctx, req.(*CommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_Stats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).Stats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/stats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).Stats(ctx, req.(*StatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/search",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).Search(ctx, req.(*SearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_SearchV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).SearchV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/searchV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).SearchV2(ctx, req.(*SearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).Delete(ctx, req.(*AddDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_DeleteByQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteByQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).DeleteByQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/deleteByQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).DeleteByQuery(ctx, req.(*DeleteByQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_DeleteAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAllDocumentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).DeleteAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/deleteAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).DeleteAll(ctx, req.(*DeleteAllDocumentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_DeleteIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).DeleteIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/deleteIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).DeleteIndex(ctx, req.(*DeleteIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_BuildSuggest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuildSuggestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).BuildSuggest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/buildSuggest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).BuildSuggest(ctx, req.(*BuildSuggestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_SuggestLookup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuggestLookupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).SuggestLookup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/suggestLookup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).SuggestLookup(ctx, req.(*SuggestLookupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_UpdateSuggest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuildSuggestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).UpdateSuggest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/updateSuggest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).UpdateSuggest(ctx, req.(*BuildSuggestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_CreateSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).CreateSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/createSnapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).CreateSnapshot(ctx, req.(*CreateSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_ReleaseSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReleaseSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).ReleaseSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/releaseSnapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).ReleaseSnapshot(ctx, req.(*ReleaseSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_GetAllSnapshotIndexGen_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllSnapshotGenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).GetAllSnapshotIndexGen(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/getAllSnapshotIndexGen",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).GetAllSnapshotIndexGen(ctx, req.(*GetAllSnapshotGenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_BackupIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BackupIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).BackupIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/backupIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).BackupIndex(ctx, req.(*BackupIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_DeleteIndexBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteIndexBackupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).DeleteIndexBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/deleteIndexBackup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).DeleteIndexBackup(ctx, req.(*DeleteIndexBackupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_BackupWarmingQueries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BackupWarmingQueriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).BackupWarmingQueries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/backupWarmingQueries",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).BackupWarmingQueries(ctx, req.(*BackupWarmingQueriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_State_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).State(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/state",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).State(ctx, req.(*StateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).Status(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_Ready_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadyCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).Ready(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/ready",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).Ready(ctx, req.(*ReadyCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_Metrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).Metrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/metrics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).Metrics(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_Indices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).Indices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/indices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).Indices(ctx, req.(*IndicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_ForceMerge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForceMergeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).ForceMerge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/forceMerge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).ForceMerge(ctx, req.(*ForceMergeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_ForceMergeDeletes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForceMergeDeletesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).ForceMergeDeletes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/forceMergeDeletes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).ForceMergeDeletes(ctx, req.(*ForceMergeDeletesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LuceneServer_Custom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CustomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuceneServerServer).Custom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.LuceneServer/custom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuceneServerServer).Custom(ctx, req.(*CustomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LuceneServer_ServiceDesc is the grpc.ServiceDesc for LuceneServer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LuceneServer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "luceneserver.LuceneServer",
	HandlerType: (*LuceneServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "createIndex",
			Handler:    _LuceneServer_CreateIndex_Handler,
		},
		{
			MethodName: "liveSettings",
			Handler:    _LuceneServer_LiveSettings_Handler,
		},
		{
			MethodName: "liveSettingsV2",
			Handler:    _LuceneServer_LiveSettingsV2_Handler,
		},
		{
			MethodName: "registerFields",
			Handler:    _LuceneServer_RegisterFields_Handler,
		},
		{
			MethodName: "updateFields",
			Handler:    _LuceneServer_UpdateFields_Handler,
		},
		{
			MethodName: "settings",
			Handler:    _LuceneServer_Settings_Handler,
		},
		{
			MethodName: "settingsV2",
			Handler:    _LuceneServer_SettingsV2_Handler,
		},
		{
			MethodName: "startIndex",
			Handler:    _LuceneServer_StartIndex_Handler,
		},
		{
			MethodName: "startIndexV2",
			Handler:    _LuceneServer_StartIndexV2_Handler,
		},
		{
			MethodName: "stopIndex",
			Handler:    _LuceneServer_StopIndex_Handler,
		},
		{
			MethodName: "reloadState",
			Handler:    _LuceneServer_ReloadState_Handler,
		},
		{
			MethodName: "refresh",
			Handler:    _LuceneServer_Refresh_Handler,
		},
		{
			MethodName: "commit",
			Handler:    _LuceneServer_Commit_Handler,
		},
		{
			MethodName: "stats",
			Handler:    _LuceneServer_Stats_Handler,
		},
		{
			MethodName: "search",
			Handler:    _LuceneServer_Search_Handler,
		},
		{
			MethodName: "searchV2",
			Handler:    _LuceneServer_SearchV2_Handler,
		},
		{
			MethodName: "delete",
			Handler:    _LuceneServer_Delete_Handler,
		},
		{
			MethodName: "deleteByQuery",
			Handler:    _LuceneServer_DeleteByQuery_Handler,
		},
		{
			MethodName: "deleteAll",
			Handler:    _LuceneServer_DeleteAll_Handler,
		},
		{
			MethodName: "deleteIndex",
			Handler:    _LuceneServer_DeleteIndex_Handler,
		},
		{
			MethodName: "buildSuggest",
			Handler:    _LuceneServer_BuildSuggest_Handler,
		},
		{
			MethodName: "suggestLookup",
			Handler:    _LuceneServer_SuggestLookup_Handler,
		},
		{
			MethodName: "updateSuggest",
			Handler:    _LuceneServer_UpdateSuggest_Handler,
		},
		{
			MethodName: "createSnapshot",
			Handler:    _LuceneServer_CreateSnapshot_Handler,
		},
		{
			MethodName: "releaseSnapshot",
			Handler:    _LuceneServer_ReleaseSnapshot_Handler,
		},
		{
			MethodName: "getAllSnapshotIndexGen",
			Handler:    _LuceneServer_GetAllSnapshotIndexGen_Handler,
		},
		{
			MethodName: "backupIndex",
			Handler:    _LuceneServer_BackupIndex_Handler,
		},
		{
			MethodName: "deleteIndexBackup",
			Handler:    _LuceneServer_DeleteIndexBackup_Handler,
		},
		{
			MethodName: "backupWarmingQueries",
			Handler:    _LuceneServer_BackupWarmingQueries_Handler,
		},
		{
			MethodName: "state",
			Handler:    _LuceneServer_State_Handler,
		},
		{
			MethodName: "status",
			Handler:    _LuceneServer_Status_Handler,
		},
		{
			MethodName: "ready",
			Handler:    _LuceneServer_Ready_Handler,
		},
		{
			MethodName: "metrics",
			Handler:    _LuceneServer_Metrics_Handler,
		},
		{
			MethodName: "indices",
			Handler:    _LuceneServer_Indices_Handler,
		},
		{
			MethodName: "forceMerge",
			Handler:    _LuceneServer_ForceMerge_Handler,
		},
		{
			MethodName: "forceMergeDeletes",
			Handler:    _LuceneServer_ForceMergeDeletes_Handler,
		},
		{
			MethodName: "custom",
			Handler:    _LuceneServer_Custom_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "addDocuments",
			Handler:       _LuceneServer_AddDocuments_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "yelp/nrtsearch/luceneserver.proto",
}

// ReplicationServerClient is the client API for ReplicationServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReplicationServerClient interface {
	// Issued by replica on primary node when it comes up
	AddReplicas(ctx context.Context, in *AddReplicaRequest, opts ...grpc.CallOption) (*AddReplicaResponse, error)
	// Issued by replica to receive CopyState from primary
	RecvCopyState(ctx context.Context, in *CopyStateRequest, opts ...grpc.CallOption) (*CopyState, error)
	// Send a file as a stream in chunks
	SendRawFile(ctx context.Context, opts ...grpc.CallOption) (ReplicationServer_SendRawFileClient, error)
	// Receives a file as a stream in chunks. Typically issued by replica on primary
	RecvRawFile(ctx context.Context, in *FileInfo, opts ...grpc.CallOption) (ReplicationServer_RecvRawFileClient, error)
	RecvRawFileV2(ctx context.Context, opts ...grpc.CallOption) (ReplicationServer_RecvRawFileV2Client, error)
	// Issued by primary on replica to inform it to start copying files either pre-warming (new merged segments) or when replica comes up first time
	CopyFiles(ctx context.Context, in *CopyFiles, opts ...grpc.CallOption) (ReplicationServer_CopyFilesClient, error)
	// Invoked externally to replica, to notify it that a new NRT point was just created on the primary
	NewNRTPoint(ctx context.Context, in *NewNRTPoint, opts ...grpc.CallOption) (*TransferStatus, error)
	// * Invoked externally to primary, to make all recent index operations searchable on the primary and, once copying is done, on the replicas
	WriteNRTPoint(ctx context.Context, in *IndexName, opts ...grpc.CallOption) (*SearcherVersion, error)
	// * Invoked externally to replica, to get the current Searcher version on replica.
	GetCurrentSearcherVersion(ctx context.Context, in *IndexName, opts ...grpc.CallOption) (*SearcherVersion, error)
	// * Invoked externally on primary to find the list of replica nodes this node is connected to for binary replication per index
	GetConnectedNodes(ctx context.Context, in *GetNodesRequest, opts ...grpc.CallOption) (*GetNodesResponse, error)
}

type replicationServerClient struct {
	cc grpc.ClientConnInterface
}

func NewReplicationServerClient(cc grpc.ClientConnInterface) ReplicationServerClient {
	return &replicationServerClient{cc}
}

func (c *replicationServerClient) AddReplicas(ctx context.Context, in *AddReplicaRequest, opts ...grpc.CallOption) (*AddReplicaResponse, error) {
	out := new(AddReplicaResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.ReplicationServer/addReplicas", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replicationServerClient) RecvCopyState(ctx context.Context, in *CopyStateRequest, opts ...grpc.CallOption) (*CopyState, error) {
	out := new(CopyState)
	err := c.cc.Invoke(ctx, "/luceneserver.ReplicationServer/recvCopyState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replicationServerClient) SendRawFile(ctx context.Context, opts ...grpc.CallOption) (ReplicationServer_SendRawFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &ReplicationServer_ServiceDesc.Streams[0], "/luceneserver.ReplicationServer/sendRawFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &replicationServerSendRawFileClient{stream}
	return x, nil
}

type ReplicationServer_SendRawFileClient interface {
	Send(*RawFileChunk) error
	CloseAndRecv() (*TransferStatus, error)
	grpc.ClientStream
}

type replicationServerSendRawFileClient struct {
	grpc.ClientStream
}

func (x *replicationServerSendRawFileClient) Send(m *RawFileChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *replicationServerSendRawFileClient) CloseAndRecv() (*TransferStatus, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(TransferStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *replicationServerClient) RecvRawFile(ctx context.Context, in *FileInfo, opts ...grpc.CallOption) (ReplicationServer_RecvRawFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &ReplicationServer_ServiceDesc.Streams[1], "/luceneserver.ReplicationServer/recvRawFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &replicationServerRecvRawFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ReplicationServer_RecvRawFileClient interface {
	Recv() (*RawFileChunk, error)
	grpc.ClientStream
}

type replicationServerRecvRawFileClient struct {
	grpc.ClientStream
}

func (x *replicationServerRecvRawFileClient) Recv() (*RawFileChunk, error) {
	m := new(RawFileChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *replicationServerClient) RecvRawFileV2(ctx context.Context, opts ...grpc.CallOption) (ReplicationServer_RecvRawFileV2Client, error) {
	stream, err := c.cc.NewStream(ctx, &ReplicationServer_ServiceDesc.Streams[2], "/luceneserver.ReplicationServer/recvRawFileV2", opts...)
	if err != nil {
		return nil, err
	}
	x := &replicationServerRecvRawFileV2Client{stream}
	return x, nil
}

type ReplicationServer_RecvRawFileV2Client interface {
	Send(*FileInfo) error
	Recv() (*RawFileChunk, error)
	grpc.ClientStream
}

type replicationServerRecvRawFileV2Client struct {
	grpc.ClientStream
}

func (x *replicationServerRecvRawFileV2Client) Send(m *FileInfo) error {
	return x.ClientStream.SendMsg(m)
}

func (x *replicationServerRecvRawFileV2Client) Recv() (*RawFileChunk, error) {
	m := new(RawFileChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *replicationServerClient) CopyFiles(ctx context.Context, in *CopyFiles, opts ...grpc.CallOption) (ReplicationServer_CopyFilesClient, error) {
	stream, err := c.cc.NewStream(ctx, &ReplicationServer_ServiceDesc.Streams[3], "/luceneserver.ReplicationServer/copyFiles", opts...)
	if err != nil {
		return nil, err
	}
	x := &replicationServerCopyFilesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ReplicationServer_CopyFilesClient interface {
	Recv() (*TransferStatus, error)
	grpc.ClientStream
}

type replicationServerCopyFilesClient struct {
	grpc.ClientStream
}

func (x *replicationServerCopyFilesClient) Recv() (*TransferStatus, error) {
	m := new(TransferStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *replicationServerClient) NewNRTPoint(ctx context.Context, in *NewNRTPoint, opts ...grpc.CallOption) (*TransferStatus, error) {
	out := new(TransferStatus)
	err := c.cc.Invoke(ctx, "/luceneserver.ReplicationServer/newNRTPoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replicationServerClient) WriteNRTPoint(ctx context.Context, in *IndexName, opts ...grpc.CallOption) (*SearcherVersion, error) {
	out := new(SearcherVersion)
	err := c.cc.Invoke(ctx, "/luceneserver.ReplicationServer/writeNRTPoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replicationServerClient) GetCurrentSearcherVersion(ctx context.Context, in *IndexName, opts ...grpc.CallOption) (*SearcherVersion, error) {
	out := new(SearcherVersion)
	err := c.cc.Invoke(ctx, "/luceneserver.ReplicationServer/getCurrentSearcherVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replicationServerClient) GetConnectedNodes(ctx context.Context, in *GetNodesRequest, opts ...grpc.CallOption) (*GetNodesResponse, error) {
	out := new(GetNodesResponse)
	err := c.cc.Invoke(ctx, "/luceneserver.ReplicationServer/getConnectedNodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReplicationServerServer is the server API for ReplicationServer service.
// All implementations must embed UnimplementedReplicationServerServer
// for forward compatibility
type ReplicationServerServer interface {
	// Issued by replica on primary node when it comes up
	AddReplicas(context.Context, *AddReplicaRequest) (*AddReplicaResponse, error)
	// Issued by replica to receive CopyState from primary
	RecvCopyState(context.Context, *CopyStateRequest) (*CopyState, error)
	// Send a file as a stream in chunks
	SendRawFile(ReplicationServer_SendRawFileServer) error
	// Receives a file as a stream in chunks. Typically issued by replica on primary
	RecvRawFile(*FileInfo, ReplicationServer_RecvRawFileServer) error
	RecvRawFileV2(ReplicationServer_RecvRawFileV2Server) error
	// Issued by primary on replica to inform it to start copying files either pre-warming (new merged segments) or when replica comes up first time
	CopyFiles(*CopyFiles, ReplicationServer_CopyFilesServer) error
	// Invoked externally to replica, to notify it that a new NRT point was just created on the primary
	NewNRTPoint(context.Context, *NewNRTPoint) (*TransferStatus, error)
	// * Invoked externally to primary, to make all recent index operations searchable on the primary and, once copying is done, on the replicas
	WriteNRTPoint(context.Context, *IndexName) (*SearcherVersion, error)
	// * Invoked externally to replica, to get the current Searcher version on replica.
	GetCurrentSearcherVersion(context.Context, *IndexName) (*SearcherVersion, error)
	// * Invoked externally on primary to find the list of replica nodes this node is connected to for binary replication per index
	GetConnectedNodes(context.Context, *GetNodesRequest) (*GetNodesResponse, error)
	mustEmbedUnimplementedReplicationServerServer()
}

// UnimplementedReplicationServerServer must be embedded to have forward compatible implementations.
type UnimplementedReplicationServerServer struct {
}

func (UnimplementedReplicationServerServer) AddReplicas(context.Context, *AddReplicaRequest) (*AddReplicaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddReplicas not implemented")
}
func (UnimplementedReplicationServerServer) RecvCopyState(context.Context, *CopyStateRequest) (*CopyState, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecvCopyState not implemented")
}
func (UnimplementedReplicationServerServer) SendRawFile(ReplicationServer_SendRawFileServer) error {
	return status.Errorf(codes.Unimplemented, "method SendRawFile not implemented")
}
func (UnimplementedReplicationServerServer) RecvRawFile(*FileInfo, ReplicationServer_RecvRawFileServer) error {
	return status.Errorf(codes.Unimplemented, "method RecvRawFile not implemented")
}
func (UnimplementedReplicationServerServer) RecvRawFileV2(ReplicationServer_RecvRawFileV2Server) error {
	return status.Errorf(codes.Unimplemented, "method RecvRawFileV2 not implemented")
}
func (UnimplementedReplicationServerServer) CopyFiles(*CopyFiles, ReplicationServer_CopyFilesServer) error {
	return status.Errorf(codes.Unimplemented, "method CopyFiles not implemented")
}
func (UnimplementedReplicationServerServer) NewNRTPoint(context.Context, *NewNRTPoint) (*TransferStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewNRTPoint not implemented")
}
func (UnimplementedReplicationServerServer) WriteNRTPoint(context.Context, *IndexName) (*SearcherVersion, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteNRTPoint not implemented")
}
func (UnimplementedReplicationServerServer) GetCurrentSearcherVersion(context.Context, *IndexName) (*SearcherVersion, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentSearcherVersion not implemented")
}
func (UnimplementedReplicationServerServer) GetConnectedNodes(context.Context, *GetNodesRequest) (*GetNodesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConnectedNodes not implemented")
}
func (UnimplementedReplicationServerServer) mustEmbedUnimplementedReplicationServerServer() {}

// UnsafeReplicationServerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReplicationServerServer will
// result in compilation errors.
type UnsafeReplicationServerServer interface {
	mustEmbedUnimplementedReplicationServerServer()
}

func RegisterReplicationServerServer(s grpc.ServiceRegistrar, srv ReplicationServerServer) {
	s.RegisterService(&ReplicationServer_ServiceDesc, srv)
}

func _ReplicationServer_AddReplicas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddReplicaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicationServerServer).AddReplicas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.ReplicationServer/addReplicas",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicationServerServer).AddReplicas(ctx, req.(*AddReplicaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplicationServer_RecvCopyState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CopyStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicationServerServer).RecvCopyState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.ReplicationServer/recvCopyState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicationServerServer).RecvCopyState(ctx, req.(*CopyStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplicationServer_SendRawFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ReplicationServerServer).SendRawFile(&replicationServerSendRawFileServer{stream})
}

type ReplicationServer_SendRawFileServer interface {
	SendAndClose(*TransferStatus) error
	Recv() (*RawFileChunk, error)
	grpc.ServerStream
}

type replicationServerSendRawFileServer struct {
	grpc.ServerStream
}

func (x *replicationServerSendRawFileServer) SendAndClose(m *TransferStatus) error {
	return x.ServerStream.SendMsg(m)
}

func (x *replicationServerSendRawFileServer) Recv() (*RawFileChunk, error) {
	m := new(RawFileChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ReplicationServer_RecvRawFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FileInfo)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ReplicationServerServer).RecvRawFile(m, &replicationServerRecvRawFileServer{stream})
}

type ReplicationServer_RecvRawFileServer interface {
	Send(*RawFileChunk) error
	grpc.ServerStream
}

type replicationServerRecvRawFileServer struct {
	grpc.ServerStream
}

func (x *replicationServerRecvRawFileServer) Send(m *RawFileChunk) error {
	return x.ServerStream.SendMsg(m)
}

func _ReplicationServer_RecvRawFileV2_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ReplicationServerServer).RecvRawFileV2(&replicationServerRecvRawFileV2Server{stream})
}

type ReplicationServer_RecvRawFileV2Server interface {
	Send(*RawFileChunk) error
	Recv() (*FileInfo, error)
	grpc.ServerStream
}

type replicationServerRecvRawFileV2Server struct {
	grpc.ServerStream
}

func (x *replicationServerRecvRawFileV2Server) Send(m *RawFileChunk) error {
	return x.ServerStream.SendMsg(m)
}

func (x *replicationServerRecvRawFileV2Server) Recv() (*FileInfo, error) {
	m := new(FileInfo)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ReplicationServer_CopyFiles_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CopyFiles)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ReplicationServerServer).CopyFiles(m, &replicationServerCopyFilesServer{stream})
}

type ReplicationServer_CopyFilesServer interface {
	Send(*TransferStatus) error
	grpc.ServerStream
}

type replicationServerCopyFilesServer struct {
	grpc.ServerStream
}

func (x *replicationServerCopyFilesServer) Send(m *TransferStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _ReplicationServer_NewNRTPoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewNRTPoint)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicationServerServer).NewNRTPoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.ReplicationServer/newNRTPoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicationServerServer).NewNRTPoint(ctx, req.(*NewNRTPoint))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplicationServer_WriteNRTPoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndexName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicationServerServer).WriteNRTPoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.ReplicationServer/writeNRTPoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicationServerServer).WriteNRTPoint(ctx, req.(*IndexName))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplicationServer_GetCurrentSearcherVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndexName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicationServerServer).GetCurrentSearcherVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.ReplicationServer/getCurrentSearcherVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicationServerServer).GetCurrentSearcherVersion(ctx, req.(*IndexName))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplicationServer_GetConnectedNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicationServerServer).GetConnectedNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/luceneserver.ReplicationServer/getConnectedNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicationServerServer).GetConnectedNodes(ctx, req.(*GetNodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ReplicationServer_ServiceDesc is the grpc.ServiceDesc for ReplicationServer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReplicationServer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "luceneserver.ReplicationServer",
	HandlerType: (*ReplicationServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "addReplicas",
			Handler:    _ReplicationServer_AddReplicas_Handler,
		},
		{
			MethodName: "recvCopyState",
			Handler:    _ReplicationServer_RecvCopyState_Handler,
		},
		{
			MethodName: "newNRTPoint",
			Handler:    _ReplicationServer_NewNRTPoint_Handler,
		},
		{
			MethodName: "writeNRTPoint",
			Handler:    _ReplicationServer_WriteNRTPoint_Handler,
		},
		{
			MethodName: "getCurrentSearcherVersion",
			Handler:    _ReplicationServer_GetCurrentSearcherVersion_Handler,
		},
		{
			MethodName: "getConnectedNodes",
			Handler:    _ReplicationServer_GetConnectedNodes_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "sendRawFile",
			Handler:       _ReplicationServer_SendRawFile_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "recvRawFile",
			Handler:       _ReplicationServer_RecvRawFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "recvRawFileV2",
			Handler:       _ReplicationServer_RecvRawFileV2_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "copyFiles",
			Handler:       _ReplicationServer_CopyFiles_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "yelp/nrtsearch/luceneserver.proto",
}
